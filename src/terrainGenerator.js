/**
 * contains function for generating terrain from tiles by approximating curve generated by NoiseGenerator.
 */




/**
 * checks if tiles is going out of bounds and corrects it by,
 * overriding slope approx,
 * upperBound and lowerBound should not be tight bounds, 
 * some margine will allow to put random tiles
 * 
 * @param {Number} cummCoord - cummulative Y-offset of current terrain
 * @param {Number} idx - approx index, approx[idx] is the current selected slope
 * @param {Array<Number>} approx - predifined slopes for tileset, must be sorted in ascending order
 */
function boundTerrainHelper(cummCoord, idx, approx, upperBound, lowerBound)
{
    let p = approx[idx];
    if(cummCoord + p <= -upperBound)
    {
        //we are up, so go down
        ///anything which is above p
        //return Math.max(...approx);
        let smoothidx = Math.max(Math.min(approx.length-1, idx+1) , Math.min(approx.length-1, idx+2));
        return approx[smoothidx];
    }
    if(cummCoord + p >= lowerBound)
    {
        //we are down , so go up
        //return Math.min(...approx);
        let smoothidx = Math.min(Math.max(0, idx-1) , Math.max(0, idx-2));
        return approx[smoothidx];
    }
    
    return p;
}


function drawTerrain(stepMap, layer, param)
{
    var debug = false; //log on console
    var curve_debug = false; //render curve
    var bound_debug = false; //render bound lines
    
    
    var tileSize = 32;
    param = {
        x: param.x ?? 0, //x coord to start on screen
        h: param.h ?? 500, //chunk height (height of layer)
        w: param.w ?? 2000, //chunk max width
        y: param.y ?? 500/2, //y coord to start on screen
        amp: param.amp ?? tileSize*10, //amplitude
        wl: param.wl ?? tileSize*5, //wavelength
        cummCoord: param.cummCoord ?? 0, //cummulative 'p'
        upperBound: param.upperBound ?? tileSize*20, // how many tiles above can terrain go,
        lowerBound: param.lowerBound ?? tileSize*20, //how many tiles below can terrain go
        targetCummCoord: param.targetCummCoord, //cummCoord where terrain should end
    };

    //return this paramaeters for creating next continuouse chunk
    let endParam = {
        cummCoord : 0, // 'p',
        tileCount: 0, //total tiles placed in this function call, Note: total tiles => absolute width of chunk in tile coords
    };

    
    let height = NoiseGenerator.getCurve()(param, tileSize);
    
    var terrainV = [];
    //approx p to nearest slope
    for(let i=1, p, minyidx, approx = [-32, -16, 0, 16, 32], cummCoord = param.cummCoord; i<height.length; i++)
    {
        p = height[i] - height[i-1];
        minyidx = 0;
        approx.forEach((d, i) => {
            if(Math.abs(p-d) < Math.abs(p-approx[minyidx]))
                minyidx = i;
        });
        p = boundTerrainHelper(cummCoord, minyidx, approx, param.upperBound, param.lowerBound);
        
        cummCoord += p;
        terrainV.push(p);

        if(param.targetCummCoord != undefined)
        {
            if(Math.abs(cummCoord - param.targetCummCoord) >= 16*(height.length-i-5))
            {
                for(let j=i+1; j<height.length; j++)
                {
                    p = (cummCoord - param.targetCummCoord > 0)? -16 : 16;
                    p = (cummCoord - param.targetCummCoord == 0)? 0 : p;
                    cummCoord += p;
                    terrainV.push(p);
                }
                //console.log(cummCoord);
                break;
            }
            
        }
    }
    

    if(debug)
        console.log(terrainV);
    
    let yCoordOffset = param.y + param.h/2;
    
    let py = param.cummCoord ?? 0;
    
    //TODO: parse stepMap from json File
    stepMap = {
        'fill': 15,
        '0_0': [1, 15],
        '0_-32': [2, 30],
        '0_16': [19, 15],
        '0_32': [3, 29],
        '0_-16': [6, 30],
        '16_0': [4, 15],
        '16_32': [21, 29],
        '16_16': [16, 15],
        '16_48': [35, 32],
        '16_-16': [33, 31],
    };

    let xCoord = param.x,
        yCoord = yCoordOffset + py, 
        yTileCount = param.h/tileSize;
    
    for(let i=0; i<terrainV.length; i++)
    {
        //genration rule for this tileset
        
        let posY = py%tileSize != 0;
        let v = terrainV[i];
        py += v;

        
        let key = (posY*16) + '_' + (posY*16 + v);
        // console.log(key + ' ' + stepMap[key]);

        yCoord += (v > 0)? 0 : v;
        
        if(curve_debug)
        {
            graphics.fillStyle(0xff6340, 1);
            graphics.fillCircle(xCoord, yCoord, 5);
        }
        

        let tileCoord = layer.worldToTileXY(xCoord, yCoord);
        let xTCoord = tileCoord.x,
            yTCoord = tileCoord.y;
        
        for(let j=0; j<stepMap[key].length; j++)
            layer.putTileAt(stepMap[key][j], xTCoord, yTCoord+j, false);
        
        //fill
        for(let j=stepMap[key].length; j<yTileCount-yTCoord; j++)
            layer.putTileAt(stepMap['fill'], xTCoord, yTCoord+j, false);

        xCoord += 32;
        yCoord += (v > 0)? v : 0;
        
    }
    
    if(bound_debug)
    {
        ///base line
        graphics.lineStyle(5, 0x03fc90, 1.0);
        graphics.strokeLineShape(
            new Phaser.Geom.Line(
                param.x, param.y + param.h/2,
                param.x + param.w, param.y + param.h/2
            )
        ).setDepth(99);
        ///upperbound
        graphics.lineStyle(5, 0xff3d4a, 1.0);
        graphics.strokeLineShape(
            new Phaser.Geom.Line(
                param.x, param.y + param.h/2 - param.upperBound,
                param.x + param.w, param.y + param.h/2 - param.upperBound
            )
        ).setDepth(99);
        ///lower bound
        graphics.lineStyle(5, 0xff3d4a, 1.0);
        graphics.strokeLineShape(
            new Phaser.Geom.Line(
                param.x, param.y + param.h/2 + param.lowerBound,
                param.x + param.w, param.y + param.h/2 + param.lowerBound
            )
        ).setDepth(99);
    }
    
    endParam.cummCoord = py;
    endParam.tileCount = terrainV.length;

    //endParam can be used to create next chunk
    return endParam;
}